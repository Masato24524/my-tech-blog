[
  {
    "source": "github",
    "id": "1e7fe29f12aa33",
    "title": "コールバック関数について調べてみる",
    "emoji": "🌟",
    "type": "tech",
    "topics": [
      "JavaScript"
    ],
    "published": true,
    "date": "2025-03-02",
    "content": "\nchatGPTを使ってコールバック関数について調べてみました。\n\n現在のレベル\n\n「コールバック関数って、関数内で呼び出される関数のことでしょ？」\n\n「なんかPromiseの登場によって使わてもよくなったやつ？」\n\n---\n\n> （質問）コールバック関数について、初学者でも分かるように説明してください。\n\n~~~\nコールバック関数（callback function）とは、ある処理が終わった後に\n「次に実行するために呼ばれる関数」のことです。\n簡単に言うと、「関数の中に渡す、後で実行される関数」 です。\n~~~\n\n#### ■コールバック関数を使う理由\n~~~\n通常、プログラムは上から下に順番に実行されますが、コールバック関数は、\n例えば非同期処理（時間がかかる処理）をした後に別の処理を行いたい場合に使います。\n~~~\n\n例えば：  \n\n・サーバーからデータを取得した後に、取得したデータを使って別の処理をしたい。  \n・ユーザーがボタンをクリックした後に、特定のアクションを実行したい。\n\n#### ■コールバック関数の基本的な使い方\n\n~~~\nコールバック関数は、他の関数に引数として渡して、実行が完了したタイミングで呼ばれます。\n~~~\n\n~~~\nfunction greet(name, callback) {\n  console.log(\"Hello, \" + name);\n  callback();  // コールバック関数を呼び出す\n}\n\nfunction sayGoodbye() {\n  console.log(\"Goodbye!\");\n}\n\ngreet(\"Alice\", sayGoodbye);  // 「Hello, Alice」が表示された後、「Goodbye!」が表示される\n~~~\n\nつまり、関数の中で呼び出される関数というだけではなく、**実行されるタイミング（非同期処理）をコントロールできる**ことが重要という訳ですね。\n\n---\n\n> （質問）Promiseとの関係について教えてください。\n\n#### ■コールバック関数とPromiseの違い\n\n~~~\nコールバック関数: \n非同期処理が完了した後に実行される関数を指定します。\n非同期処理が複雑になると、コールバック関数が入れ子（ネスト）になって、\nコードが見づらくなることがあります（これを「コールバック地獄」と呼びます）。\n~~~\n\n~~~\nPromise: \n非同期処理を扱うためのオブジェクトで、処理が成功した場合や失敗した場合に\nどのように結果を扱うかを指定します。\nPromiseは、非同期処理が完了する前に値を返さない代わりに、\n後で結果が返ってくることを約束（Promise）するものです。\n~~~\n\n#### ■Promiseを使った例\n\n~~~\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const data = \"データ取得成功!\";\n      resolve(data);  // データ取得成功した場合\n    }, 1000);\n  });\n}\n\nfetchData()\n  .then(result => {\n    console.log(result);  // データ取得成功!\n    return \"次の処理\";\n  })\n  .then(nextResult => {\n    console.log(nextResult);  // 次の処理\n  })\n  .catch(error => {\n    console.error(\"エラー:\", error);  // エラー処理\n  });\n  ~~~\n\n  #### ■Promiseを使うメリット\n- 非同期処理のチェーン: .then() を使って、非同期処理の結果を順番に処理することができます。\n- エラーハンドリング: .catch() でエラーを一元的に処理できます。\n- 可読性の向上: 非同期処理の順番が明確になり、コードが読みやすくなります。\n\n---\n\n> （質問）Promiseでなく、コールバック関数を使わざるを得ない場合はありますか？\n\n解答はいくつかあったのですが、下記が重要と感じました。\n\n#### ■イベントリスナー（リアルタイム処理）の場合\n\n~~~\nPromiseは一度しか解決（resolve/reject）できないため、\n繰り返し発生するイベントには向いていません。\nイベントリスナーを使う場合は、コールバック関数が必要になります。\n~~~\n\n~~~\ndocument.addEventListener(\"click\", () => {\n  console.log(\"クリックされました！\");\n});\n~~~\n\n---\n\n> なぜPromiseを使えない？\n\n~~~\nPromise は 一度しか実行されない ため、複数回のクリックを処理できません。\nイベントが発生するたびに実行される処理は、コールバック関数が最適です。\n~~~\n\n#### ■JavaScriptの一部の非同期処理（例えば、setTimeout）\n\n~~~\nsetTimeout や setInterval などの組み込み関数は、コールバック関数しか受け付けません。\n~~~\n\n~~~\nsetTimeout(() => {\n  console.log(\"3秒後に実行されました！\");\n}, 3000);\n~~~\n\n---\n\n### まとめ\n\n今回はコールバック関数について調べました。\n\nとりあえずPromiseを使っていればいいやと思っていましたが、コールバック関数が必要になるケースについても知ることができました。\n\n次はasync/awaitとの関係についても学習したいと思いますが、長くなりそうなので一旦区切りたいと思います。"
  },
  {
    "source": "github",
    "id": "20e160a92416ac",
    "title": "NextjsのRoute Segment Config(レンダリング＆キャッシュ)設定",
    "emoji": "📌",
    "type": "tech",
    "topics": [
      "Nextjs"
    ],
    "published": true,
    "date": "2025-04-04",
    "content": "\n現在ブログサイトをVercelからCloudflareに移行しようとしているのですが、\nedge runtimeの設定が理解できておらずデプロイが上手くいっていません。。。\nedge runtimeを理解する前段階として、NextjsのSSRおよびキャッシュ設定の関係について調べてみたいと思います。\n※ブログサイトではNext.js 14/ App Routerを使用しています。\n\n---\n\n#### ■不明点（現在のブログサイトでの設定）\n1. 「force-dynamic」がどのように働いているか？\n2. 「cache: no-store」がどのように働いているか？\n3. 「runtime edge」との関係は？\n\n3.は別記事にする予定で、今回は1.と2.について調べます。\n\n※そもそもなぜ「force-dynamic」「cache: no-store」の設定にしているかなんですが、\nビルド時にfetchでAPIルートを読みにいったときに、ページを生成前のため404になってしまう（**SSG**にしようとする）というエラーを回避するため、止む無く設定しました。\n\n> SSG(Static Site Generation)・・・ビルド時（デプロイ時）に複数のHTMLを生成してしまうので、クライアント側からアクセスするときは軽量に行える。SPAは毎回クライアント側でindex.htmlを生成するので、その点が異なる。\n\n---\n\n### ■「force-dynamic」の挙動\n\n✅ force-dynamic とは何か？\n- **Route Segment Config**（ルートセグメント構成）に属する設定\n- リクエスト時に毎回データを取得して、ページの生成を常に動的にする。\n- キャッシュを無効化して、毎回サーバーサイドでデータを取得する。\n- SSR扱いになる（SSGにしない）\n- fetchが自動的にcache: ' no-store ' 扱いになる。\n\n**注意点**\n- CDNキャッシュが効かないため、パフォーマンスが落ちる\n\n> Route Segment Config ・・・以下のように、各セグメントのファイル（page.tsx, layout.tsx, template.tsx など）で使える設定\n> \n> Route Segment Config 例\n> export const dynamic = \"force-dynamic\";\n> export const revalidate = 60;\n> export const fetchCache = \"force-no-store\";\n> export const runtime = \"edge\";\n>\n> Next.js 14以降では、これらを page.tsx などのファイルの「トップレベル」で宣言する必要がある。\n\n### ■「cache: no-store」の挙動\n\n✅ fetchだけキャッシュさせたくない場合に使用する\n　force-dynamicがページ全体をSSR化させるのに対して、cache: no-storeはfetchのみに適用することができます。\n\n　今回の場合、私は両方同時に適用していましたが、force-dynamicを設定している時点で特に不要（二重設定）となっていました。\n\n### ■その他のRoute Segment Config\n\n|Option\t|Type\t|Default|\n|---|---|---|\nexperimental_ppr|\tboolean\t|\ndynamic\t'auto' | 'force-dynamic' | 'error' | 'force-static'\t'auto'\ndynamicParams|\tboolean\ttrue\nrevalidate\tfalse | 0 | number\tfalse\nfetchCache|\t'auto' / 'default-cache' / 'only-cache' / 'force-cache' / 'force-no-store' / 'default-no-store' / 'only-no-store'\t|'auto'\nruntime|\t'nodejs' / 'edge'\t|'nodejs'\npreferredRegion|\t'auto' / 'global' / 'home' / string / string[]\t|'auto'\nmaxDuration|\tnumber|\tSet by deployment platform\n\n✅ revalidate\n\n　ISR（Incremental Static Regeneration） の時間を設定します。再生成が行われる時間間隔を指定でき、ページがキャッシュされてから次に再生成されるまでの待機時間を設定できます。\n　例えば、revalidate: 60 とすると、ページが最初に生成された後、60秒ごとに再生成されます。\n\n~~~\nexport const revalidate = 60; // 60秒ごとに再生成\n~~~\n<br />\n\n✅ runtime\n\n　ここで「runtime」が登場します。実は**Route Segment Config**の設定に含まれるんですね（知らなかった・・・）\n　ページがどの実行環境で動作するかを指定します。\n　runtime: \"edge\" と設定すると、そのページが Vercel Edge Functions のようなエッジネットワーク上で実行されることを指定します。\n　runtime: \"nodejs\" に設定すると、通常のNode.jsサーバー上で実行されます。\n\n\n---\n\n参考資料：\nhttps://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config\n\nhttps://zenn.dev/rinda_1994/articles/e6d8e3150b312d\n\n---\n\n### さいごに\n　今回、SSR/SSGについてページを読み込むときの挙動もそうなんですが、同時にビルド時にどういったことを行っているかも理解を深めることができました。\n\n　Nextjsの理解について、一歩前進した気がします！"
  },
  {
    "source": "github",
    "id": "49aef95c1253c2",
    "title": "AWSで問い合わせフォーマットを作成（SAAハンズオントレーニング）",
    "emoji": "🎉",
    "type": "tech",
    "topics": [
      "AWS"
    ],
    "published": true,
    "date": "2025-03-13",
    "update": "2025-08-25",
    "content": "AWS SAAを受講予定なので、ハンズオントレーニングを兼ねてブログサイトの問い合わせフォームを作成してみました。\n\n↓実際の問い合わせフォーム\n\nhttps://www.masato-tech-blog.com/pages/contact\n\n備忘録も兼ねて詰まったポイントのみ記載しておきます。\n\n---\n## 全体構成\n\nAPI Gateway、Lambda、DynamoDBを使ったサーバレスアーキテクチャとなります。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/49aef95c1253c2/image-2.png)\n\nコストについても、個人利用の範囲ではほぼ無料で維持できそうです。\n\n## 目次\n\n1. DynamoDBの設定\n2. Lambda関数の作成\n3. API Gatewayのセットアップ\n4. 問い合わせフォームの作成\n\n## 1. DynamoDBの設定\nここでは新規テーブルの作成を行うぐらいですが、下記に少し手間どりました。\n\n（詰まったポイント）\n- パーティションキーの文字列はLamda関数のコードに合わせます。\n\n~~~\n    // DynamoDBに保存するアイテムを作成\n    const item = {\n      id: uuidv4(), // ユニークIDを生成\n      name: body.name,\n      email: body.email,\n      message: body.message,\n      subject: body.subject || '',\n      submittedAt: new Date().toISOString(),\n    };\n~~~\n\nここの「id」の部分ですね。\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/49aef95c1253c2/image.png)\n\n例えばkeyという名前にするなら、パーティションキーにも「key」という名前を設定します。\n\n---\n\nあと作成されたテーブルデータは「項目を探索」の方から参照できます。\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/49aef95c1253c2/image-1.png)\n\nダッシュボードとかテーブルの方ばかり見て、送信したデータが登録されず、悩んでいる時間がありました。。。\n\n---\n\n## 2. Lambda関数の作成\n（詰まったポイント）\nコードに関してはcommonJS形式で書くのが推奨されるようです。（Claudeの回答）\n\n~~~\nAWS Lambda環境との親和性:\n\nAWS Lambdaは伝統的にCommonJS形式で設計されており、デフォルトの実装例やドキュメントもすべてCommonJS形式です\nLambda環境は長年CommonJSをサポートしてきたため、安定性と互換性が高いです\n\n\nAWS SDKとの互換性:\n\nAWS SDKは主にCommonJS形式を想定して開発されています\n特に古いバージョンのAWS SDKでは、ES Modulesでの使用時に予期しない問題が発生することがあります\n\n\n依存ライブラリとの互換性:\n\nLambdaでよくCDKを使った場合に含まれる多くの依存ライブラリ（例：uuid）はCommonJS形式を前提としていることが多いです\nES Modulesで使う場合、インポート方法を調整する必要がある場合があります\n\n\nシンプルさと保守性:\n\nNode.jsの世界ではまだCommonJSが広く使われており、多くの開発者にとって馴染みがあります\n実装方法がシンプルで、トラブルシューティングも容易です\n~~~\n\n下手にmjs（ESmodules）形式に直したりしていたので、再修正が必要となりました。\n\n## 3. API Gatewayのセットアップ\n\n'25/8/25追記\n各設定項目について調べ直したので追記しておきます。\n最初に表示した図の紫線での囲み部分ですね。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/49aef95c1253c2/image-2.png)\n\n- メソッドリクエスト\n役割：クライアントからのHTTPリクエストを受け取る最初のゲート\n\n- 統合リクエスト\n役割：メソッドリクエストからのデータを変換して、バックエンド（Lambda）に送信\n\n- 統合レスポンス\n役割：バックエンド（Lambda）からのレスポンスを受け取り、メソッドレスポンスに向けて変換\n\n- メソッドレスポンス\n役割：クライアントに返すHTTPレスポンスの形式を定義\n\n- Lambdaプロキシ統合\n役割：プロキシ統合を使うことで、API Gateway の設定画面で行っていた複雑な設定作業（※1）を、全てプログラムコード（Lambda関数）内で制御できる。\n上記の統合リクエスト/レスポンスの設定は基本的に不要（無効）となる\n※1「HTTPリクエスト解析・バリデーション」「動的ルーティング・パス制御」「データ変換・マッピング」「レスポンス変換」「エラーハンドリング」「ログ制御」など\n\n### （詰まったポイント）\nここではフロントエンド（Next.js）側のリソースパスの設定が抜けており、時間を要しました。\n\n~~~\n<.env.local>\nNEXT_PUBLIC_CONTACT_API_URL=\"https://XXXXXXXXXX.execute-api.ap-northeast-1.amazonaws.com/prod/contact\"\n~~~\n\n最後に「/contact」が必要となります。\nAWSのAPI Gateway→「ステージ」の画面でURLをコピーすると、「/contact」がついてきません。。。\n\n\n## 4. 問い合わせフォームの作成\n\n完成画面はこんな感じです。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/49aef95c1253c2/image4.png)\n\n今回はどちらかというと**1～3の設定の方がより重要**だったので、\nClaudeで出力してもらったものをそのまま使用しています。\n\n\n### まとめ\nAPI Gateway、Lambda、DynamoDBはSAA試験にも頻出のサービスと思いますので、今回のハンズオントレーニングで中身の理解がだいぶ進んだと思います。\n満足できる内容となりました。"
  },
  {
    "source": "github",
    "id": "4d248db052a364",
    "title": "Promiseについて調べてみた",
    "emoji": "🦔",
    "type": "tech",
    "topics": [
      "JavaScript"
    ],
    "published": true,
    "date": "2025-03-11",
    "content": "\n前回、chatGPTを使ってコールバック関数について調べてみました。\n\nhttps://zenn.dev/masato24524/articles/1e7fe29f12aa33\n\n\n\n今回はasync/awaitについて調べてみます、、、と思ったのですが\nその前にPromiseのきちんとした理解が必要そうです。\nPromiseは非同期処理の際の結果に応じて処理を指定できるというものでした。\n\n---\n\n> （質問）そもそもJavaScriptのPromiseってなに？  \n\n#### Promiseとは？\n\n~~~\nPromise は、非同期処理の結果を表すオブジェクト です。\n非同期処理が 成功するか失敗するか を表し、それに応じた処理を行うことができます。\n~~~\n\nなるほど。オブジェクトなので、プロパティとメソッドを持つはずですね。\n\n\n> （質問）Promiseはオブジェクトなので、プロパティとメソッドを含みますか？\n\n~~~\nはい、Promise は オブジェクト なので、プロパティやメソッドを持ちます。\nただし、Promise の特性上、プロパティはほとんど使われず、\n『主にメソッドを利用』します。\n~~~\n\nつまり最低限、メソッドの理解が必要ということになりそうです。  \n\n(202/3/15追記)\n- Promiseには「内部ステータス」と「メソッド」が存在します。\n- プロパティについてはほとんど使われずというより、定義上存在しないようです。  \n\n\n|項目\t|内部ステータス（state）\t|メソッド\n|----|----|----|\n役割\t|Promiseの進行状況を管理\t|Promiseを操作・処理する\n種類\t|pending / fulfilled / rejected\t|.then() / .catch() / .finally() など\n\n---\n\n### Promiseの内部ステータス\n|状態\t|説明|\n|----|----|\npending（待機中）|\t初期状態（非同期処理が終わっていない）\nfulfilled（成功）\t|非同期処理が成功し、resolve() が呼ばれた\nrejected（失敗）\t|非同期処理が失敗し、reject() が呼ばれた\n\n---\n\n> （質問）Promiseの引数のresolve, rejectとはなんですか？\n\n#### Promiseの考え方\n- 今すぐ結果がわからなくても、将来結果が得られることを約束する\n- 成功（resolve） か 失敗（reject） のどちらかに必ず決着する\n\n#### Promiseの実装方法\n\n✅ 1. resolve() を使う（成功時）\n~~~\nconst successPromise = new Promise((resolve) => {\n  setTimeout(() => resolve(\"成功！\"), 1000);\n});\n\nsuccessPromise.then(console.log); // 1秒後に \"成功！\"\n~~~\n\n✅ 2. reject() を使う（失敗時）\n\n~~~\nconst failurePromise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(\"エラー！\"), 1000);\n});\n\nfailurePromise.catch(console.error); // 1秒後に \"エラー！\"\n~~~\n\n---\n\n\n### Promiseのメソッド\n✅ 1. then() と catch()\n\nここで.thenと.catchが出てきました。\n初学者にとっては少しとっつき辛いやつです。。。\n\n\n> （質問）Promiseのthenとcatchはそれぞれ成功時と失敗時のメソッドを呼び出すものという理解であっていますか？\n\n~~~\nはい、その理解で合っています！\nthen は 成功時の処理（resolve） を、catch は 失敗時の処理（reject） を呼び出すためのメソッドです。\n~~~\n\n##### then と catch の基本\n\n■then(onFulfilled, onRejected)\n- 第1引数 (onFulfilled) → resolve() のときに実行される（成功時）\n- 第2引数 (onRejected) → reject() のときに実行される（失敗時）\n\n~~~\nconst p = new Promise((resolve, reject) => {\n  const success = true;\n  success ? resolve(\"成功！\") : reject(\"失敗！\");\n});\n\np.then(\n  result => console.log(\"成功:\", result), // 成功時の処理\n  error => console.error(\"失敗:\", error)  // 失敗時の処理（省略可能）\n);\n~~~\n\n- 成功時 → console.log(\"成功: 成功！\") が実行\n- 失敗時 → console.error(\"失敗: 失敗！\") が実行\n\n\n■catch(onRejected)\ncatch() は then() の 第2引数 の代わりになる\nエラーハンドリングを then() とは別に分けたいとき に使う\n\n~~~\nconst p = new Promise((resolve, reject) => {\n  reject(\"エラーが発生しました！\");\n});\n\n// 失敗時の処理をcatchで実行\np.then(result => console.log(\"成功:\", result))\n .catch(error => console.error(\"失敗:\", error));\n ~~~\n\n- catch() は チェーンの途中でエラーをキャッチできる のが強み！\n\n---\n\n✅ 2. finally()（成功・失敗どちらでも実行）\n\n~~~\nfetchData()\n  .then(console.log)\n  .catch(console.error)\n  .finally(() => console.log(\"処理終了！\"));\n~~~\n\n---\n\n\n✅ 3. Promise.all()（すべて成功したら実行）\n~~~\nconst p1 = new Promise(resolve => setTimeout(() => resolve(\"p1 完了\"), 1000));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(\"p2 完了\"), 2000));\n\nPromise.all([p1, p2]).then(console.log); // [\"p1 完了\", \"p2 完了\"]\n~~~\n\n---\n\n### まとめ\n~~プロパティなども理解しようとするともう少し複雑そうですが、~~\n基本はこんなところでしょうか。\n自身としてはこれまで非同期処理はfetch（async/await）ぐらいで、\nPromiseを使う機会は少なかったのですがこれで少し理解できた気がします。\n次回はasync/awaitについて調べてみたいと思います。"
  },
  {
    "source": "github",
    "id": "59a6f8460cd6a3",
    "title": "React.memo/useMemo/useCallbackの学習",
    "emoji": "🔥",
    "type": "tech",
    "topics": [
      "React"
    ],
    "published": true,
    "date": "2025-05-03",
    "content": "\n今回はReact.memo/useMemo/useCallbackについて学習します。\n\n参考にしたのは下記のYoutube。\n\n【ShinCode camp】レンダリングを最適化してWebパフォーマンスを向上させてみよう\n\nhttps://www.youtube.com/watch?v=GvPBr43lJk0\n\n### 目次\n1. React developer toolの導入\n2. React.memoの使い方\n3. useMemoの使い方\n4. useCallbackの使い方\n\n### 1. React developer toolの導入\n\nレンダリングしている箇所を把握するため、React developer tool(chromeの拡張機能)を導入します。<br>\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image1.png)<br>\n\n開発者ツールを開いて、Componentsを選択した後、「Higlight updates when components render.」にチェックを入れる<br>\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image2.png)\n\nレンダリングされた場合、レンダリング箇所が水色の枠線で囲まれます。\n\nuseStateで文字を入力するたびにレンダリングされていることが確認できます。\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/movie-1.gif)\n\n※先ほど選択したComponentsではなく、Profilerのタブで何秒かかったか詳細を確認できるようです。\n\n\n\n### 2. React.memoの使い方\n\n通常、親コンポーネントが更新されると、それにぶら下がっている子コンポーネントについても一緒に再レンダリングされてしまいます。\n\nReact.memoを使うと、子コンポーネントが再レンダリングされてしまうことを防ぐことができます。\n\n下記のような単純な親コンポーネントと子コンポーネントを作成します。\n\n~~~javascript\nconst Child1 = () => {\n  return (\n    <>\n      <p>子コンポーネントです。</p>\n    </>\n  );\n};\n\nexport default function Parent() {\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setText(e.target.value);\n  };\n\n  return (\n    <div>\n      <p>親コンポーネントです</p>\n      <input\n        type=\"text\"\n        onChange={handleChange}\n        value={text}\n        className=\"border-2 border-slate-200 rounded-md\"\n      />\n      <Child1 />\n    </div>\n  );\n}\n~~~\n<br>\n先ほどのツールで親コンポーネントの更新時に、子コンポーネントもレンダリングされていることを確認。<br>\n\n静止画のみだと少し分かりにくいですが、親コンポーネントを更新（input欄に文字を入力、または削除）すると、Child1コンポーネントの部分も更新されています。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image3.png)\n<br>\n\n次に、子コンポーネントをReact.memo()で囲ってやります。\n\n~~~javascript\nconst Child1 = React.memo(() => {\n  return (\n    <>\n      <p>子コンポーネントです。</p>\n    </>\n  );\n});\n~~~\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image4.png)\n\n子コンポーネントは、親コンポーネントを更新してもレンダリングされないことが確認できました。（先ほどと違い「Child1」の表示なし）<br>\n\n### 3. useMemoの使い方\n\nuseMemoを使うと、今度は関数の無駄な再レンダリングを防ぐことができます。\n\n分かりやすように、下記のコードのようなwhile文で何回も繰り返すような重い計算処理を追加します。\n\nwhile文の中身は、親コンポーネントがレンダリングされるたび（今回の場合、input欄に文字入力を行うたび）に重い計算処理の部分が実行されることになります。\n\n~~~javascript\nexport default function Parent() {\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setText(e.target.value);\n  };\n\n  // 重い計算処理の部分　ここから\n  const [count, setCount] = useState(0);\n  const double = (count: number) => {\n    let i = 0;\n    while (i < 30000000) {\n      i++;\n    }\n    return count * 2;\n  };\n  const doubleCount = double(count);\n  // ここまで\n\n  return (\n    <div>\n      <p>親コンポーネントです</p>\n      <input\n        type=\"text\"\n        onChange={handleChange}\n        value={text}\n        className=\"border-2 border-slate-200 rounded-md\"\n      />\n      <p>親コンポーネントで重い計算処理</p>\n      <p>\n        Counter: {count}, {doubleCount}\n      </p>\n      <button\n        className=\"border-2 rounded-md\"\n        onClick={() => setCount(count + 1)}\n      >\n        Increment Count2\n      </button>\n    </div>\n  );\n}\n~~~\n\n**＜実行結果＞**\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image5.png)\n\n\nuseMemoを下記のようにdouble関数の部分に適用します。\n\nこのとき、第二引数に[count]を指定します。\n\nこうすると、countが更新されたときのみdouble関数の部分を実行し、countが更新されていない場合はこの処理はスキップされます。\n\n~~~javascript\nconst doubleCount = useMemo(() => double(count), [count]);\n~~~\n\n**＜実行結果＞**\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image6.png)\n\n親コンポーネントを更新（input欄に文字を入力）しても、レンダリング時間が増えなくなりました。\n\n### 4. useCallbackの使い方\n\nuseCallbackを使うと、関数の再生成を防ぐことができます。\n\nuseMemoと何が違うの？とちょっと思ったんですが、\n\n- useMemo・・・計算結果が同じ場合にキャッシュ（メモ化）する\n- useCallback・・・関数自体の再生成を防ぐ（関数の中身が同じなら同じ関数を再利用する）\n\nといった違いがあるようです。\n\n~~~javascript\n\n// Child1コンポーネントにpropsとしてhandleClickを渡す\nconst Child1 = React.memo((props: { handleClick: () => void }) => {\n  return (\n    <>\n      <p>Child1コンポーネントです。</p>\n      <button className=\"border-2 rounded-md p-1\" onClick={props.handleClick}>\n        Click\n      </button>\n    </>\n  );\n});\n\nexport default function Parent() {\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setText(e.target.value);\n  };\n\n　// handleClick関数を追加\n  const handleClick = () => {\n    console.log(\"click\");\n  };\n  // ここまで\n\n  return (\n    <div>\n      <p>親コンポーネントです</p>\n      <input\n        type=\"text\"\n        onChange={handleChange}\n        value={text}\n        className=\"border-2 border-slate-200 rounded-md\"\n      />\n      <p></p>\n      <br />\n      <Child1 handleClick={handleClick} />\n    </div>\n  );\n}\n~~~\n\n**＜実行結果＞**\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image7.png)\n\nこのケースでは、親コンポーネントがレンダリングされるたびにhandleClick関数が再生成され、それをpropsとして受け取っているChild1も再レンダリングされます。\n\n（上記の結果でAnonymousと表示されている部分でChild1が再生成されています）\n\nこれを防ぐため、useCallbackをhandleClickに適用してやります。\n\n~~~javascript\n  const handleClick = useCallback(() => {\n    console.log(\"click\");\n  }, []);\n~~~\n\n第二引数は基本は空配列にしておきます。\n\nこうすると最初にページがマウントされたときのみレンダリングが行われます。\n\n※仮に[text]を入力すると、textが変更されるたびにレンダリングが行われるので、今回のケースでは意味がなくなります。\n\n**＜実行結果＞**\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/59a6f8460cd6a3/image8.png)\n\n親コンポーネントを更新しても、Child1コンポーネント（Anonymousの表示）が再レンダリングされることはなくなりました。\n\n### 所感\n\n注意点として、全てに対してuseMemo、useCallbackを使うのではなく、ボトルネックとなっている箇所を特定してメモ化を行うのが推奨されるようです。\n\n（メモ化するだけでもメモリを使ったりするので逆効果になるケースもあり得るとのこと）\n\n記事の内容だけでは分かりにくかった方は、一度冒頭に紹介した動画も確認してみてください。\n\n非常に分かりやすくまとめられており、今回の内容が理解できるのではと思います。\n"
  },
  {
    "source": "github",
    "id": "65bfd4816baffb",
    "title": "データレイク/Kinesis Firehoseを使ったデータ分析(AWS SAAハンズオントレーニング)",
    "emoji": "📌",
    "type": "tech",
    "topics": [
      "AWS"
    ],
    "published": true,
    "date": "2025-05-10",
    "content": "\n### はじめに\n\n今回はSAA試験に向けたハンズオントレーニングの二回目について記載します。\n\n前回の記事はこちら：\n\nhttps://zenn.dev/masato24524/articles/49aef95c1253c2\n\n現在Udemyの問題集で学習を続けているのですが、Kinesis（Streams、Firehose、Apache Flink）の問題が結構出てくるにもかかわらず、理解が浅いせいか解答/解説を見てもなかなかしっくりきません。\n\n【SAA-C03版】AWS 認定ソリューションアーキテクト アソシエイト模擬試験問題集（6回分390問）\nhttps://www.udemy.com/course/aws-knan/\n\nググってみたところ、2020年と少し古いですがKinesis Firehoseを使ったハンズオントレーニングの記事があったので、それを実践してみようと思います。\n\nhttps://dev.classmethod.jp/articles/ws-summit-online-2020-hol-1/\n\nメインはデータレイク周りの構成を構築することなので、データレイク周りの知識を習得するのにも役立ちそうです。\n\nちなみにこれだけのサービスを使います。\n\n- **Amazon S3(Simple Storage Service)**　※AWSでデータレイクとは、S3内で構築するという理解でいいようです\n- Amazon VPC\n- Amazon EC2\n- AWS CloudFormation\n- AWS IAM\n- **Amazon Kinesis Data Firehose**\n- Amazon Athena\n- Amazon QuickSight\n\n盛り沢山ですね(^^;\n\n前回同様、記事にならってハンズオンを行い、詰まった点に関して備忘録として記載していこうと思います。\n\n\n### 目次\n\n1. CloudFormationでVPC, EC2を作成する\n2. IAMロールの作成\n3. SSMコンソールでの確認\n4. Kinesis Firehoseの設定\n5. Glueでのデータ抽出とテーブル作成\n6. Athenaによるクエリの実行\n7. QuickSightでの可視化\n8. 後片付け\n\n---\n\n### 1. CloudFormationでVPC, EC2を作成する\n\nまずは記事に従ってキーペアを作成します。\n\n最新環境ではEC2のキーペアの中にタイプの選択があります。\nこちらはRSAを選択しました。\n\n> キーペア（Key Pair）とは、AWS EC2インスタンスに安全にログイン（SSH接続）するために使用される暗号鍵のペア\n\n> EC2のキーペアの「タイプ」は、使用される暗号アルゴリズムの種類\nRSAの方が互換性が高く、無難な選択（ED25519の方が最新式でセキュリティは高いとされる）\n\nCloudFormationは記事で与えられたyamlファイルを使用しますが、\nスタックの作成時にパラメータの設定が必要なので、\n\nKeyPair：handson\n\nRoleName : hansdon-minlake\n\nとしました。\n\nKeyPairは先ほど作成したもので、RoleNameについては記事の中では前後していますが、後ほどhandson-minlakeという名前でIAMロールを作成するのでそれに合わせます。\n\n#### EC2インスタンスの作成エラー\n\nCREATE_FAILEDのエラーが発生しました。\n\nこれはEC2のAMI IDが記事当時のもので古いためなので、最新のものにyamlファイルを書き換えます。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-1.png)\n\n無料枠のLinux2023/t2.microを選択して、AMI IDをコピーして、yamlファイルを更新します。\n\n**※最初Linux2で実施したのですが、Firehoseプラグインのインストールのあたりでうまくいかなくなりました**\n\n再度CloudFormatinoのスタックを作成し直したところ、状態がCOMPLETEとなり正常に完了しました。\n\n---\n\n### 2. IAMロールの作成\n\n記事内ではIAMロールを新規作成するように書かれていますが、CloudFormationによって「handson-minlake」というIAMロールが既に作成されています。\n\nなので上記のIAMロールを選択した後、許可を追加→ポリシーをアタッチと選択し、「AmazonEC2RoleforSSM」のポリシーを追加します。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-2.png)\n\n> 記事内で急にSSMという言葉が出てきますが、SSM（AWS Systems Manager）とは、AWSが提供するEC2などのインスタンスやシステムの運用・管理を簡単にするためのマネージドサービスになります。\n\n次にIAMロールの割り当てですが、下記から行えます。\n\nEC2→アクション→セキュリティ→IAMロールを変更\n\n**※こちらもCloudFormationで既に設定済みのようでした。**\n\n### 3. SSMコンソールでの確認\n\n元記事ではログが2分おきに出力されるとのことでしたが、その設定が見当たりません（AMIにカスタムされていた？）\n\n仕方がないので、代わりに下記をセッションマネージャーのコンソール画面で実行します。\n\n**(注意！)下記のコマンドで問題が発生した場合は各自で調べてみてください**\n\n~~~\n// rootユーザーに切り替え\nsudo su - \n\n// ディレクトリを作成\nmkdir -p /root/es-demo \n\n// スクリプトファイルを作成\ncat <<EOF > /root/es-demo/testlog.sh\n#!/bin/bash\n\nwhile true; do\n  timestamp=\\$(date \"+[%Y-%m-%d %H:%M:%S+0900]\")\n  log_message=\"\\$timestamp INFO prd-web001 uehara 1001 [This is Information.]\"\n  echo \"\\$log_message\" >> /root/es-demo/testapp.log\n  sleep 120\ndone\nEOF\n\n// 実行権限を付与\nchmod +x /root/es-demo/testlog.sh　\n\n// バックグラウンドでスクリプトを実行\nnohup /root/es-demo/testlog.sh &　\n\n// ログファイルの中身を確認\ncat /root/es-demo/testapp.log\n\n~~~\n\n成功すると、記事と同じようなログが2分ごとに出力されます。\n\n~~~\n[2025-05-10 05:38:46+0900] INFO prd-web001 uehara 1001 [This is Information.]\n[2025-05-10 05:40:46+0900] INFO prd-web001 uehara 1001 [This is Information.]\n[2025-05-10 05:42:46+0900] INFO prd-web001 uehara 1001 [This is Information.]\n[2025-05-10 05:44:46+0900] INFO prd-web001 uehara 1001 [This is Information.]\n~~~\n\nあとの設定は記事通りで問題なさそうでした。\n\n### 4. Kinesis Firehoseの設定\n\n引き続きSSMのコンソール画面（root）で進めていきます。\n\n記事には記載がないですが、先にgem/rubyなどの必要なパッケージをインストールする必要があります。\n\nまた、Fluentdを起動するまで、その他の設定についても記事以外の手順を踏むことになります。\n\n（Amazon Linux2023ではtd-agentのサポート対象外のため）\n\n中身がすべて理解できるのがベストではあるのですが、\n\n時間の兼ね合いもあり、今回は設定ファイルなどはClaudeに聞いたものを使用しました。\n\n~~~\n\n# rootユーザーに切り替え\nsudo su -\n\n# 必要なパッケージのインストール\nsudo dnf install -y ruby ruby-devel gcc gcc-c++ make\n\n# Fluentd と Kinesis プラグインをインストール\nsudo gem install fluentd\nsudo gem install fluent-plugin-kinesis\n\n# 設定ディレクトリを作成\nsudo mkdir -p /etc/fluentd\nsudo mkdir -p /var/log/fluentd/buffer\n\nsudo mkdir -p /var/log/fluentd/buffer/firehose\nsudo chmod -R 755 /var/log/fluentd\n\n# Firehose 用の設定ファイルを作成\ncat << EOF | sudo tee /etc/fluentd/fluentd.conf\n# ログ設定\n<system>\n  log_level info\n  <log>\n    format json\n    time_format %Y-%m-%d %H:%M:%S\n  </log>\n</system>\n\n# EC2のログファイルを監視\n<source>\n  @type tail\n  path /root/es-demo/testapp.log\n  pos_file /var/log/fluentd/testapp.log.pos\n  \n  # ログフォーマット定義\n  format /^\\[(?<timestamp>[^ ]* [^ ]*)\\] (?<alarmlevel>[^ ]*) *? (?<host>[^ ]*) * (?<user>[^ ]*) * (?<number>.*) \\[(?<text>.*)\\]$/\n  time_format %d/%b/%Y:%H:%M:%S %z\n  \n  # データ型変換\n  types size:integer, status:integer, reqtime:float, runtime:float, time:time\n  \n  # タグ設定\n  tag testappec2.log\n</source>\n\n# Firehose経由でS3へ送信\n<match testappec2.log>\n  @type kinesis_firehose\n  \n  # AWS設定\n  region ap-northeast-1  # 使用するリージョンに変更\n  delivery_stream_name minilake1  # 既存のFirehoseストリーム名\n  \n  # EC2のIAMロールを使用（推奨）\n  # aws_key_id とaws_sec_keyは明示的に設定せず、IAMロールに依存\n  \n  # 出力フォーマット\n  <format>\n    @type json\n  </format>\n  \n  # バッファ設定\n  <buffer>\n    @type file\n    path /var/log/fluentd/buffer/firehose\n    flush_interval 1s  # 例に合わせて1秒に設定\n    chunk_limit_size 1m\n    retry_forever true\n    retry_max_interval 30\n    flush_thread_count 4\n  </buffer>\n</match>\n\n# システムのヘルスチェック用ログ（オプション）\n<source>\n  @type monitor_agent\n  bind 0.0.0.0\n  port 24220\n</source>\nEOF\n\n# サービス定義を作成\ncat << EOF | sudo tee /etc/systemd/system/fluentd.service\n[Unit]\nDescription=Fluentd\nAfter=network.target\n\n[Service]\nType=simple\nUser=root\nExecStart=/usr/local/bin/fluentd -c /etc/fluentd/fluentd.conf\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# サービスを有効化・起動\nsudo systemctl daemon-reload\nsudo systemctl enable fluentd\nsudo systemctl start fluentd\n\n 状態確認\nsudo systemctl status fluentd\n\n~~~\n\nstatusを確認して、fluentd.serviceがactive(runnning)になっていればOKです。\n\nS3にminilake-in1のフォルダが作成されており、下の階層にファイルができていれば成功ですが、フォルダやファイルが見当たらなければ設定を見直す必要があります。\n\n### 5. Glueでのデータ抽出とテーブル作成\n\nGlueの画面ですが、なぜか英語で表示される・・・\n\n以下に実行した手順をメモしておきます。\n\nData CatalogからCrawlersを選択→Create crawlerを選択\n\nChoose data sources and classifiersではAdd a data sourceからS3 pathを選択し、データが保存されているS3バケットを選択してパスを追加します。\n\nIAM　roleで作成しているIAMロールを選択します。\n\nAdd databaseでデータベースを新規作成します。名前を付けるだけでOKですが、元のSet output and schedulingのページでTarget databaseの再読み込みボタンを押さないと作成したデータベースが表示されません。\n\n実行が成功すると、S3データからGlueによってデータベーステーブルが作成されます。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-3.png)\n\n### 6. Athenaによるクエリの実行\n\n使用を開始のTrinoSQLを使用してデータをクエリする（S3分析の場合はこちらのようです）を選択し、クエリエディタを起動します。\n\n最初にクエリ結果の保存場所を指定する必要があります。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-4.png)\n\n作成したテーブルが表示されていることを確認し、右側の三点からテーブルをプレビューを選択\n\nクエリ文を少しカスタマイズしてやると、必要な行だけを抽出できます。\n\n~~~SQL\nSELECT * FROM \"minilake\".\"20250510_handson_minilake_tiger\" where user= 'uehara' AND partition_1 = '2025' AND partition_2 = '05' AND partition_3 = '10';\n~~~\n\n### 7. QuickSightでの可視化\n\nいよいよ最後の項目です。\n\nQuickSightで取得したデータの可視化を行います。\n\n最初にアカウントの登録が必要となるようです。\n\n（無料枠は30日間のみ？）\n\nS3とAthenaが選択していることを確認しておきます。\n\n下の方に**ピクセルパーフェクトレポート（月額料金が発生します）**とあるのでチェックを外しておきます。\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-5.png)\n\n取得したデータについて、グラフを表示させることができます。\n\nログ数が少ないのと、似たようなデータばかりなので味気ないグラフですが・・・\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/65bfd4816baffb/image-6.png)\n\n### 8. 後片付け\n\n記事にも記載がありますが、EC2などを起動したままにしておくと課金が継続されるため、不要なAWSリソースは停止しておきましょう。（できれば削除しておくのがベストです）\n\n特にEC2（停止より削除推奨）、Elastic IP（VPCから確認可能、割り当てがないと課金される。関連付けを解除してから、解放を選択）、S3（バケットを空にするのが大事）は注意してください。\n\n**※CloudFormationのスタックを削除すると、作成したときと同じリソースを削除してくれるんですね。便利！**\n\n### さいごに\n\n今回得られた知見を下記します。\n\n- ~~IAMロールはSSM側(操作する側)ではなく、EC2側（アクセスされる側)に設定する~~\n\n> **【※5/15訂正】EC2がSSM Agentを使ってSSMにアクセスする、が正確なようです**\n\n- CloudFormationの便利さを体感。テンプレートファイルを使えばどのユーザーでも一発で複数の必要リソースが作成可能（IAMロールだって作れる）\n\n- FirehoseはS3へと直接データを吐き出せる（間に別のリソースは不要）\n\n- AWS触るならLinuxの知識（コマンド）が必須\n\n特にFirehose（データ取得）　→　S3（データレイク）　→　Glue（テーブル作成）→ Athena（SQLクエリ分析）　と試験に頻出のリソースの連携が頭の中にイメージしやすくなり、実践してみて良かったと思います。\n\n来週はいよいよSAA試験を受講予定なので、ラストスパートを頑張っていきます。"
  },
  {
    "source": "github",
    "id": "70a90ae2a5ae35",
    "title": "『レンダリングとマウント』をJavaScript、React、Nextjsで比較",
    "emoji": "🐡",
    "type": "tech",
    "topics": [
      "JavaScript",
      "React",
      "Nextjs"
    ],
    "published": true,
    "date": "2025-3-23",
    "content": "\n**下記の記事はClaudeに質問して出力してもらった内容を、自分で理解しながら追記/修正したものになります。**\n<br/>\n\n---\n（Claudeによる出力）\n↓↓↓↓ここから↓↓↓↓\n\n## はじめに\nReactを学び始めると、「レンダリング」や「マウント」といった用語に出会います。これらは似ているようで異なる概念であり、しっかり理解することでより効率的なReactアプリケーションが作れるようになります。\n\nこの記事では、JavaScriptの基本から始めて、React、そしてNext.jsでの「レンダリング」と「マウント」の違いを初心者にもわかりやすく解説します。\n\n## 目次\n\n1. [基本概念：レンダリングとマウントとは？](#基本概念レンダリングとマウントとは)\n2. [JavaScriptでの要素表示の仕組み](#javascriptでの要素表示の仕組み)\n3. [Reactにおけるレンダリングとマウント](#reactにおけるレンダリングとマウント)\n4. [Next.jsの特徴とレンダリング戦略](#nextjsの特徴とレンダリング戦略)\n5. [実践：コーディング時に意識すべきポイント](#実践コーディング時に意識すべきポイント)\n6. [よくある問題とその解決法](#よくある問題とその解決法)\n7. [まとめ](#まとめ)\n\n## 基本概念：レンダリングとマウントとは？\n\n### レンダリングとは\n\n**レンダリング**とは、簡単に言えば「画面に表示するための準備をする過程」です。\n\n- **JavaScriptでは**: HTML要素を作成してDOMに追加する作業\n- **Reactでは**: コンポーネントの状態から仮想DOMを計算する作業\n- **Next.jsでは**: サーバーまたはビルド時にHTMLを生成する作業\n\n### マウントとは\n\n**マウント**とは、「準備したものを実際に画面に表示する過程」です。\n\n- **JavaScriptでは**: 明確な「マウント」という概念はなく、DOM要素の追加と同義\n- **Reactでは**: 仮想DOMを実際のDOMに反映させる作業\n- **Next.jsでは**: サーバーレンダリングされたHTMLをクライアント側で「ハイドレーション」する作業\n\n#### （追記）用語解説\n■仮想DOM・・・JavaScript上で実際のDOM（Document Object Model）を抽象化した軽量なコピーを指します。React や Vue.js などのフレームワークで使われ、効率的なUI更新を実現するための仕組み。\n\n＜仮想DOMを使うメリット＞\n- パフォーマンスの向上\n直接DOMを操作すると遅くなるが、仮想DOMを使うことで最小限の更新で済む。\n- コードのシンプル化\nDOM操作を直接書く必要がなくなり、状態管理が簡単になる。\n- バグを減らせる\n直接DOMを触るより安全で、意図しない更新を防げる。\n<br />\n\n■ハイドレーション・・・サーバーサイドレンダリング（SSR）で生成されたHTMLに、クライアント側でReactのイベントや状態を復元し、インタラクティブにするプロセス のこと。(**仕組みについて、後述があります**)\n<br />\n＜ハイドレーションのメリット＞\n✅ 高速な初回表示\n　→ SSRによって最初のHTMLがすぐに描画される。\n\n✅ SEOに強い\n　→ HTMLが事前に生成されるため、Googleのクローラーが認識しやすい。\n\n✅ クライアント側の負荷を軽減\n　→ 必要な部分のみReactで管理することで、クライアントの処理負担が減る。\n\n---\n\n\n## JavaScriptでの要素表示の仕組み\n\nJavaScriptでは、DOM API を使って要素を作成し、表示します。\n\n```javascript\n// 新しい要素を作成\nconst newElement = document.createElement('div');\nnewElement.textContent = 'こんにちは！';\n\n// 作成した要素をDOMに追加（これで画面に表示される）\ndocument.getElementById('container').appendChild(newElement);\n```\n\n注意点：\n- DOM操作は比較的重い処理\n- 大量のDOM操作はパフォーマンスに影響する\n\n**初心者向けTips**:\n- 大量の要素を追加する場合は、`DocumentFragment`を使うとパフォーマンスが向上します\n- JavaScriptファイルの読み込みはレンダリングをブロックするので、`defer`や`async`属性の使用を検討しましょう\n\n## Reactにおけるレンダリングとマウント\n\nReactでは、「レンダリング」と「マウント」が明確に分かれています。\n\n### Reactのレンダリングプロセス\n\n1. コンポーネントが評価される（関数コンポーネントが実行される）\n2. JSXが仮想DOM（Virtual DOM）に変換される\n3. 前回の仮想DOMと比較される（差分検出）\n\n```jsx\nfunction Greeting({ name }) {\n  return <h1>こんにちは、{name}さん！</h1>;\n}\n\n// このコンポーネントが評価されるとレンダリングが行われる\n```\n\n### Reactのマウントプロセス\n\n1. 差分が検出されたら、実際のDOMを更新する\n2. 更新されたDOMが画面に反映される\n\n```jsx\n// 初回マウント\nReactDOM.render(<App />, document.getElementById('root'));\n\n// React 18以降\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n### 重要なライフサイクル\n\nコンポーネントには、以下のような「ライフサイクル」があります：\n\n1. **マウント時**：コンポーネントが初めてDOMに追加される\n2. **更新時**：propsや状態が変わってコンポーネントが再レンダリングされる\n3. **アンマウント時**：コンポーネントがDOMから削除される\n\n```jsx\nimport { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('コンポーネントがマウントされました');\n    \n    return () => {\n      console.log('コンポーネントがアンマウントされます');\n    };\n  }, []); // 空の依存配列でマウント時のみ実行\n  \n  return <div>Hello React</div>;\n}\n```\n\n**初心者向けTips**:\n- `useEffect`の依存配列が空の場合、マウント時のみ実行されます\n- DOM操作や外部APIとの通信は`useEffect`内で行いましょう\n- レンダリング中に副作用（APIコールなど）を起こさないようにしましょう\n\n## Next.jsの特徴とレンダリング戦略\n\nNext.jsは、Reactをベースに、サーバーサイドレンダリング（SSR）や静的サイト生成（SSG）を簡単に実装できるフレームワークです。\n\n### Next.jsのレンダリング方式\n\n1. **サーバーサイドレンダリング (SSR)**\n   - サーバーでHTMLを生成し、クライアントに送信\n   - ユーザーごとに異なるコンテンツに最適\n   \n   ```jsx\n   // pages/ssr-page.js\n   export async function getServerSideProps() {\n     const res = await fetch('https://api.example.com/data');\n     const data = await res.json();\n     return { props: { data } };\n   }\n   \n   function SSRPage({ data }) {\n     return <div>{data.title}</div>;\n   }\n   ```\n\n2. **静的サイト生成 (SSG)**\n   - ビルド時にHTMLを生成\n   - ブログ記事など、頻繁に変更されないコンテンツに最適\n   \n   ```jsx\n   // pages/ssg-page.js\n   export async function getStaticProps() {\n     const res = await fetch('https://api.example.com/data');\n     const data = await res.json();\n     return { props: { data } };\n   }\n   \n   function SSGPage({ data }) {\n     return <div>{data.title}</div>;\n   }\n   ```\n\n3. **クライアントサイドレンダリング (CSR)**\n   - 通常のReactと同じように、クライアント側でレンダリング\n   \n   ```jsx\n   // pages/csr-page.js\n   import { useEffect, useState } from 'react';\n   \n   function CSRPage() {\n     const [data, setData] = useState(null);\n     \n     useEffect(() => {\n       async function fetchData() {\n         const res = await fetch('https://api.example.com/data');\n         const data = await res.json();\n         setData(data);\n       }\n       fetchData();\n     }, []);\n     \n     if (!data) return <div>Loading...</div>;\n     return <div>{data.title}</div>;\n   }\n   ```\n\n### ハイドレーション\n\nNext.jsでは、サーバーからHTMLを受け取った後、Reactがそのマークアップを「ハイドレーション」します。これは、静的なHTMLにイベントリスナーなどの機能を付与するプロセスです。\n\nハイドレーションのステップ：\n1. サーバーから生成されたHTMLを受け取る\n2. JavaScriptが読み込まれる\n3. Reactがサーバーで生成されたDOMと一致するように仮想DOMを構築\n4. イベントリスナーを追加し、インタラクティブにする\n\n**初心者向けTips**:\n- ハイドレーションエラーを避けるため、サーバーとクライアントで生成されるHTMLが一致するようにする\n- `window`や`document`などのブラウザAPI使用時には注意が必要（サーバーでは使えない）\n\n## 実践：コーディング時に意識すべきポイント\n\n### レンダリングの最適化\n\n1. **不要な再レンダリングを防ぐ**\n   ```jsx\n   // コンポーネントのメモ化\n   const MemoizedComponent = React.memo(MyComponent);\n   \n   // 計算値のメモ化\n   const calculatedValue = useMemo(() => expensiveCalculation(a, b), [a, b]);\n   \n   // コールバック関数のメモ化\n   const handleClick = useCallback(() => {\n     console.log('クリックされました');\n   }, []);\n   ```\n\n2. **状態の更新を最小限に**\n   ```jsx\n   // 悪い例\n   const [user, setUser] = useState({ name: 'Taro', age: 25 });\n   \n   // 一部だけ更新したい場合でも全体を更新してしまう\n   setUser({ name: 'Jiro', age: 25 });\n   \n   // 良い例\n   setUser(prevUser => ({ ...prevUser, name: 'Jiro' }));\n   ```\n\n### マウント時の処理\n\n1. **DOMの参照を取得する**\n   ```jsx\n   import { useRef, useEffect } from 'react';\n   \n   function MyComponent() {\n     const myElementRef = useRef(null);\n     \n     useEffect(() => {\n       // マウント後にDOMノードにアクセス可能\n       if (myElementRef.current) {\n         myElementRef.current.focus();\n       }\n     }, []);\n     \n     return <input ref={myElementRef} />;\n   }\n   ```\n\n2. **クリーンアップ関数の重要性**\n   ```jsx\n   useEffect(() => {\n     const subscription = someAPI.subscribe();\n     \n     // クリーンアップ関数（アンマウント時に実行される）\n     return () => {\n       subscription.unsubscribe();\n     };\n   }, []);\n   ```\n\n### Next.jsでのデータ取得タイミング\n\n```jsx\n// SSRでのデータ取得\nexport async function getServerSideProps() {\n  // リクエストごとに実行される\n  return { props: { /* データ */ } };\n}\n\n// SSGでのデータ取得\nexport async function getStaticProps() {\n  // ビルド時のみ実行される\n  return { props: { /* データ */ } };\n}\n\n// クライアントサイドでのデータ取得\nfunction ClientComponent() {\n  const { data, error } = useSWR('/api/data', fetcher);\n  // ...\n}\n```\n\n## よくある問題とその解決法\n\n### 1. 無限ループに陥るuseEffect\n\n```jsx\n// 問題のあるコード\nfunction BadComponent() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    setCount(count + 1); // 状態が更新されるとuseEffectが再実行される\n  }); // 依存配列がない！\n  \n  return <div>{count}</div>;\n}\n\n// 解決策\nfunction GoodComponent() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    // 初回のみ実行\n    setCount(prevCount => prevCount + 1);\n  }, []); // 空の依存配列\n  \n  return <div>{count}</div>;\n}\n```\n\n### 2. ハイドレーションエラー\n\n```jsx\n// 問題のあるコード\nfunction DateComponent() {\n  // サーバーとクライアントで異なる値になる\n  return <div>{new Date().toLocaleString()}</div>;\n}\n\n// 解決策\nfunction SafeDateComponent() {\n  const [date, setDate] = useState(null);\n  \n  useEffect(() => {\n    setDate(new Date().toLocaleString());\n  }, []);\n  \n  return <div>{date || 'Loading...'}</div>;\n}\n```\n\n### 3. パフォーマンス問題\n\n```jsx\n// 問題のあるコード\nfunction ExpensiveComponent({ data }) {\n  // データが変わるたびに高コストな計算\n  const processedData = expensiveOperation(data);\n  \n  return <div>{processedData}</div>;\n}\n\n// 解決策\nfunction OptimizedComponent({ data }) {\n  // データが変わった場合のみ計算\n  const processedData = useMemo(() => {\n    return expensiveOperation(data);\n  }, [data]);\n  \n  return <div>{processedData}</div>;\n}\n```\n\n## まとめ\n\nReactと Next.js でアプリケーションを開発する際、レンダリングとマウントの違いを理解することは非常に重要です。\n\n### 覚えておくべきポイント\n\n1. **レンダリング** はUIを計算する過程、**マウント** は計算したUIを実際のDOMに反映する過程\n2. **useEffect** の依存配列を正しく設定し、無限ループを避ける\n3. サーバーサイドとクライアントサイドの違いを理解し、**ハイドレーションエラー**を防ぐ\n4. **メモ化**（React.memo, useMemo, useCallback）を活用して最適化する\n5. 適切な**レンダリング戦略**（SSR, SSG, CSR）を選択する\n\nReactでの開発経験を積みながら、これらの概念をより深く理解していきましょう。最初は難しく感じるかもしれませんが、少しずつ実践していくことで、効率的で高パフォーマンスなアプリケーションを構築できるようになります。\n\n### 参考資料\n\n- [React公式ドキュメント](https://reactjs.org/docs/getting-started.html)\n- [Next.js公式ドキュメント](https://nextjs.org/docs)\n- [React Hook API リファレンス](https://reactjs.org/docs/hooks-reference.html)\n\n---\n\n（Claudeによる出力）\n↑↑↑↑ここまで↑↑↑↑\n\n## さいごに\n以上がClaudeに解説してもらった内容になります。\n\nブログサイトを作成する際の技術スタックとしてNextjsを選択したのですが、あまりCSR/SSGとSSRの使い分けができておらず無駄な部分は結構ありそう・・・。\nかといって直すにはまだ知識不足な気がします。\n\n継続して学習していきたいと思います。\n"
  },
  {
    "source": "github",
    "id": "9c772857328066",
    "title": "React特有の型定義",
    "emoji": "📘",
    "type": "tech",
    "topics": [
      "React",
      "TypeScript"
    ],
    "published": true,
    "date": "2025-03-27",
    "content": "\nReactをTypeScriptで書いたときの型定義が個人的にややこしかったのでまとめてみます。\nすべて挙げるともっとたくさんあるのでしょうが、家計簿アプリ（Udemy教材）を以前作成したときに出てきたものを中心にピックアップしました。\n\n---\n**＜目次＞**\n1. React.ReactNode\n2. React.FC\n3. React.ChangeEvent\n4. React.MouseEvent\n5. React.Dispatch\n6. React.SetStateAction\n7. React.ComponentType\n\n---\n\n#### 1. React.ReactNode\n\nコンポーネントの子要素として渡せるすべての型に対して記述するユニオン型。\n> ユニオン型・・・2つ以上の型をパイプ記号（｜）で繋げて書く。\n\n~~~\n  type ReactNode = string | number | bigint | boolean | ReactElement<any, string | \n  JSXElementConstructor<any>> | Iterable<ReactNode> | ReactPortal | Promise<...> | \n  null | undefined\n~~~\n\nReactElement型も包括する。\n> ReactElement型・・・JSX要素のみを指し、文字列や数値のようなプリミティブ値は含まない。\n\n---\n\n#### 2. React.FC\n\nFCはFunctionComponentの略。\n関数コンポーネントに対して定義する。\n~~~\ntype Props = { message: string };\nconst MyComponent: React.FC<Props> = ({ message }) => <p>{message}</p>;\n~~~\n上記のように使用して、propsの型定義ができる。\n> props・・・親コンポーネントから子コンポーネントに渡すデータ のこと。\n\nコンポーネントの戻り値の型（JSX.Element）を省略できる。\n\n\n最近のTypeScriptではReact.FCを使わずに書くのが推奨される場合もある。\n~~~\ntype Props = { title: string };\nconst MyComponent = ({ title }: Props): JSX.Element => {\n  return <h1>{title}</h1>;\n};\n~~~\n\n---\n#### 3. React.ChangeEvent\nフォーム要素（input、textarea、select など）の onChange イベントハンドラーで使われる。\n\n~~~\nconst TextInput = () => {\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setText(event.target.value);\n  };\n\n  return (\n    <input type=\"text\" value={text} onChange={handleChange} />\n  );\n};\n~~~\n\n---\n#### 4. React.MouseEvent\nマウス操作に関連するイベント（click、mouseover、mousedown など）を扱うときに使われる。\n\n~~~\nconst ButtonComponent = () => {\n  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {\n    console.log(\"Button clicked!\", event);\n  };\n\n  return <button onClick={handleClick}>Click Me</button>;\n};\n~~~\n---\n#### 『5. React.Dispatch』 & 『6. React.SetStateAction』\nReact.Dispatch・・・状態更新関数（setState）の型を表す。\nReact.SetStateAction・・・状態更新のために渡す値の型を表す。通常、setState 関数に渡す値の型として使う。\n下記の場合だと、prevCount が React.SetStateAction<number> 型\n~~~\nconst [count, setCount] = useState<number>(0);\n\n// setCount: React.Dispatch<React.SetStateAction<number>>\nconst increment = () => {\n  setCount(prevCount => prevCount + 1); // prevCount は React.SetStateAction<number> 型\n};\n~~~\n---\n\n#### 7. React.ComponentType\nコンポーネントの型を定義するために使う。特に、コンポーネントを動的に扱うときや、他のコンポーネントに渡すときに便利。\n> コンポーネント・・・UIを構成する部品のこと。\n\nReact.ComponentType の使いどころ\n1. コンポーネントを props として渡す場合\n\n2. コンポーネントの型が動的に決まる場合\n\n3. 高階コンポーネントを作成するとき\n\n4. 汎用的なコンポーネントを受け取るとき\n\n上記のうち、2以外の例を挙げます。\n\n**（例）1. コンポーネントを props として渡す場合**\n　コンポーネントが受け取る props の型 と、返す JSX 要素の型 を指定するために使われる。\n~~~\n// 任意の Props を持つコンポーネントの型\ntype MyComponentProps = {\n  message: string;\n};\n\nconst MyComponent: React.FC<MyComponentProps> = ({ message }) => {\n  return <p>{message}</p>;\n};\n\n// コンポーネントを props として受け取るコンポーネント\ntype WrapperProps = {\n  Component: React.ComponentType<MyComponentProps>;\n};\n\nconst Wrapper: React.FC<WrapperProps> = ({ Component }) => {\n  return <Component message=\"Hello, World!\" />;\n};\n\nconst App: React.FC = () => {\n  return <Wrapper Component={MyComponent} />;\n};\n\n~~~\nchatGPTに挙げてもらった例で少し分かりにくいですが、「Component」 コンポーネントが「MyConponent」コンポーネントをpropsとして受け取っています。\n<br/>\n**（例）3. 高階コンポーネントを作成するとき**\n　高階コンポーネントは、他のコンポーネントをラップして拡張するパターン。\n　このときに React.ComponentType を使って、引数や返り値としてコンポーネントを扱う。\n~~~\n// 受け取るコンポーネントの型\ntype WithLoadingProps = {\n  isLoading: boolean;\n};\n\n// 高階コンポーネントの型\nconst withLoading = <P extends object>(\n  Component: React.ComponentType<P>\n) => {\n  return (props: P & WithLoadingProps) => {\n    if (props.isLoading) {\n      return <div>Loading...</div>;\n    }\n    return <Component {...props} />;\n  };\n};\n\n// 基本のコンポーネント\nconst MyComponent: React.FC<WithLoadingProps> = ({ isLoading }) => {\n  return <div>{isLoading ? \"Loading...\" : \"Data Loaded!\"}</div>;\n};\n\n// 高階コンポーネントを使用\nconst MyComponentWithLoading = withLoading(MyComponent);\n\nconst App: React.FC = () => {\n  return <MyComponentWithLoading isLoading={false} />;\n};\n\n~~~\n\n**（例）4. 汎用的なコンポーネントを受け取るとき**\n実際に家計簿アプリの中で使っていたのはこれかなと。\n\n~~~\ninterface menuItem {\n  text: string | React.ReactNode,\n  path: string,\n  icon: React.ComponentType,\n}\n\nconst Sidebar = ({drawerWidth, mobileOpen, handleDrawerTransitionEnd, handleDrawerClose}: SidebarProps) => {\n  const pathname = usePathname();\n\n  const MenuItems: menuItem[] = [\n    {text: \"Home\", path: \"/home\", icon: HomeIcon},\n    {text: <Typography>月間<br />ﾚﾎﾟｰﾄ</Typography>, path: \"/report\", icon: QueryStatsIcon},\n  ]\n~~~\n\niconに対してComponentTyepを適用しています。\n- アイコンは単なる画像ではなく、インタラクティブな要素やスタイリングを含む可能性がある\n- 関数コンポーネントとクラスコンポーネントの両方の型を受け入れることができる→様々なアイコンライブラリ（Material-UI等）のコンポーネントを使用できる\n- アイコンコンポーネントは、サイズ、色、その他のスタイルプロパティを受け取る必要がある場合がある\n\n\n**＜React.ComponentType と React.FC の違い＞**\nReact.FC (Functional Component) は、コンポーネントに渡される children プロパティ を自動的に扱う。\n\nReact.ComponentType は、コンポーネントの型を props の型を含めて 定義するために使う。children を考慮せず、より汎用的な型を提供する。\n\n---\n参考資料：\nhttps://ja.react.dev/learn/typescript#typing-dom-events\nhttps://react-typescript-cheatsheet.netlify.app/\n\n## さいごに\n今回思ったのは公式ドキュメントみたいなものがはっきりしなくて、中々調べにくいですね。\n\n最初にコードを書こうとしたときはReactNodeとかFCとか、ぱっと見て何のことか非常に分かりにくかったです。\n今後も使う種類が増えたときにまた調べ直してみたいと思います。\n\n\n"
  },
  {
    "source": "github",
    "id": "9f41703ed4e1ea",
    "title": "正規表現について調べてみた(初学者向け)",
    "emoji": "☕",
    "type": "tech",
    "topics": [
      "JavaScript",
      "正規表現"
    ],
    "published": true,
    "date": "2025-02-23",
    "content": "\nchatGPTを使って正規表現について調べてみました。\n\n> （質問）JavaScriptにおける正規表現とは何ですか？\n\n~~~\nJavaScriptにおける正規表現（Regular Expression, RegExp）とは、\n文字列の検索や置換を効率的に行うためのパターンを表すオブジェクトです。\nRegExp オブジェクトを使用すると、特定の文字列パターンを\n簡単に検索、抽出、置換することができます。\n~~~\n\n(・_・D フムフム\n・・・いまいちよく分かりません。\n\n> （質問）何のために使われるか？使うとどのようなメリットがありますか？\n\n1. 正規表現の主な用途  \nJavaScriptの正規表現は、主に文字列の操作やデータの検証に使われます。  \n2. 正規表現を使うメリット  \n正規表現を使うことで、コードの可読性やメンテナンス性が向上し、パフォーマンスの最適化にもつながります。\n\n---\n\n・・・これでもよく分かりません。\n\n> （質問）\n> 「正規表現」という言葉の意味が分からないので、説明してください。\n> なぜ「正規」なのでしょうか？\n\n~~~\n「正規（regular）」という言葉には、「規則性がある」「一定の法則に従っている」\nという意味があります。\n「正規表現」＝「規則的なパターンを記述する表現方法」 という意味になります。\nこの「正規（regular）」の由来は、数学・計算機科学の「正規言語（Regular Language）」\nという概念に基づいています。\n「文字列のパターンを扱う方法」 として「正規表現（Regular Expression）」が生まれました。\n~~~\n\n> （質問）つまり一定のパターンを表現することができるようになる・・・？\n\n~~~\nそうです！正規表現は「一定のパターンを表現するためのルールや記法」です。\nたとえば、以下のようなパターンを表現できます。\n~~~\n\n✅ 一定のパターンを表現する例\n\n|パターン|\t    正規表現|\t                                            マッチする例|\n|----|----|----|\n|数字だけ|\t    /^\\d+$/\t\"12345\",  |                                      \"987654\"|\n|英字だけ|\t    /`^[a-zA-Z]`+$/|\t                                        \"hello\", \"JavaScript\"|\n|メールアドレス|\t/`^[a-zA-Z0-9._%+-]`+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\t|    \"test@example.com\"|\n|ひらがなだけ|\t/`^[ぁ-ん]`+$/|\t                                        \"こんにちは\", \"さくら\"|\n|電話番号|\t    /^\\d{3}-\\d{4}-\\d{4}$/|\t                                \"090-1234-5678\"|\n\n✅ もっと複雑なパターンも作れる\n例えば、「Hello で始まり ! で終わる文章」というパターンを表現すると：\n\n~~~\nconst regex = /^Hello.*!$/;\nconsole.log(regex.test(\"Hello, world!\")); // true\nconsole.log(regex.test(\"Hi, world!\")); // false\n~~~\n\nｰｰｰ\n\n### まとめ\n\nここまで来てようやくどういったものか分かる気がしてきました。\n個人的に「正規」表現という名前が初学者にとっては理解を妨げている気がします。\n今回はここまでですが、扱えることが必須のようなのでこれから少しずつ覚えていきたいと思います。\n\n"
  },
  {
    "source": "github",
    "id": "aac1c1a02f5c48",
    "title": "Next.js（Vercel）のブログサイトをCloudflareに移行",
    "emoji": "✨",
    "type": "tech",
    "topics": [
      "nextjs",
      "blog",
      "vercel",
      "cloudflare"
    ],
    "published": true,
    "date": "2025-04-12",
    "content": "\n前回記事でも述べたように、\n現在ブログサイトをVercelからCloudflareに移行しようとしているのですが、\nデプロイが上手くいっていませんでした。\n\nhttps://zenn.dev/masato24524/articles/20e160a92416ac\n\nようやく解決したので、詰まった点を備忘録として記載しておきます。\n\n---\n\n#### ■Cloudflareの移行に必要な作業\n1. next-on-pagesを適用する\n2. edge runtimeを適用する\n\n\n#### ■問題と対策（１）\n「1.next-on-pagesを適用する」まではOKです。\n\n「2.edge runtimeを適用する」について、ページによっては下記のようなエラーが発生していました。\n\n「Error: This browser does not support document.implementation.createHTMLDocument」\n\n一部のページで取得した記事を\"html-react-parser\"を使ってparseしていたのですが、\nどうもruntime edgeでは上記は実行できないようです。\n\nchatGPTの回答↓\n~~~\nruntime: \"edge\" を指定すると：\n実行環境が V8（Cloudflare Workersと似た軽量JS環境） になります。\n\nこの環境では document.implementation.createHTMLDocument のようなDOM操作系APIが存在しません。\n\nそのため、html-react-parser や react-html-parser のようなライブラリが内部で DOM を使っていると、\nEdge 環境ではエラーになります。\n~~~\n\n対策として、parseしている部分を別のコンポーネント化して、use clientで実行してあげます。\n\n~~~\nParse.tsx\n\n\"use client\";\n\nimport parse from \"html-react-parser\";\nimport React from \"react\";\n\n// Parseコンポーネント\nconst ParseHtml = ({ blogContent }: any) => {\n  return (\n    <div id=\"blog-doc\" className=\"inline-block mb-10 pt-4\">\n      {parse(blogContent)}\n    </div>\n  );\n};\n\nexport default ParseHtml;\n~~~\n\nこのParseHtmlをruntime edgeを適用している親コンポーネントから呼び出します。\n\n~~~\npage.tsx\n\nexport const runtime = \"edge\";\n\n～～省略～～\n\nreturn (\n    ～～省略～～\n          {/* パースをuse clientで実行 */}\n          <ParseHtml blogContent={blogContent} />\n    ～～省略～～\n)\n~~~\n\nこれでエラーが解決しました。\n\n---\n\n#### ■問題と対策（２）\n上記は対策できたのですが、次にruntime edgeを適用してもビルドエラーが発生するページが出てきました。\n\n~~~\n10:43:55.027\t⚡️ ERROR: Failed to produce a Cloudflare Pages build from the project.\n10:43:55.027\t⚡️ \n10:43:55.028\t⚡️ \tThe following routes were not configured to run with the Edge Runtime:\n10:43:55.028\t⚡️ \t  - /pages/[pageId]\n10:43:55.028\t⚡️ \t  - /pages/contact\n10:43:55.028\t⚡️ \t  - /pages/portfolio\n10:43:55.028\t⚡️ \t  - /pages/works\n10:43:55.028\t⚡️ \n10:43:55.028\t⚡️ \tPlease make sure that all your non-static routes export the following edge runtime route segment config:\n10:43:55.029\t⚡️ \t  export const runtime = 'edge';\n~~~\n\n「export const runtime = 'edge';」 は記載しているはずなのに、\nなぜ・・・(-_-;)\n\n問題は**app router形式なのに、pagesというディレクトリを使用していること**でした。\napp router形式は通常appフォルダの直下に各フォルダを配置します。\n\n一方pages router形式はpagesフォルダの直下に各フォルダを配置するのですが、\n今回app router形式にも関わらず、app/pagesとなるフォルダを作成してしまっているためその場合はruntime edgeが適用されないという仕様になっているようです。\n\n（※特に意識せずにpagesという名前にしていたのですが、それが良くなかった）\n\npagesフォルダの中身をappフォルダの直下に移動することで、無事に解決しました。\n\n---\n\n### さいごに\n解決策は割と単純だったんですが、そこにたどり着くまでがエラーの内容を理解できていないと難しいですね。\n\n同じ問題に遭遇している人がいるか分かりませんが、ヒントになれば幸いです。\n\n\n"
  },
  {
    "source": "github",
    "id": "cfc67b6a077aeb",
    "title": "AWS Solutions Architect - Associate（SAA-C03)試験に合格しました",
    "emoji": "👏",
    "type": "tech",
    "topics": [
      "AWS"
    ],
    "published": true,
    "date": "2025-05-24",
    "content": "\n### はじめに\n\nAWS SAA試験に合格しました！\n\n![alt text](https://raw.githubusercontent.com/Masato24524/Zenn-contents/main/images/cfc67b6a077aeb/image-1.png)\n\n試験は1000点満点で、720点以上で合格なので、多少ですが余裕をもって合格できたのかなと思います。\n\n気が早いですが、3年後に再認定試験が必要となるようですので、その時のメモにもなると思い、今回は学習方法などを記載しておこうと思います。\n\nちなみにAWSの実務は未経験で、総学習時間はだいたい100～110時間程度となります。\n\n主な学習方法は目次の3種類に分類されますが、同じように実務未経験でこれから学習を始める方で参考にしたいという方がいれば、後半で記載しているハンズオントーレニングの①から実施するのをおすすめします。\n\n試験にも頻出の主要機能と、AWSがどんなものかいち早くつかめるからです。\n\n（初心者向けなので、解説が充実しており、予備知識がなくてもOKです。）\n\n### 目次\n1. Youtube\n2. 模擬問題集\n3. ハンズオントレーニング\n\n---\n\n### 1. Youtube\n\n**AWS認定Solution Architect Associate対策コース**\n\nMaruchin tech chさん\n\nhttps://www.youtube.com/watch?v=t_fnQReLeAY&t=28320s\n\n約8時間半と長編の動画ですが、試験に出やすい項目が一通り網羅されています。\n\nまず一通りは最初から視聴し、その後は必要な項目だけ復習として見直していました。\n\nhttps://www.youtube.com/watch?v=fsz6G45A4H4&t=2102s\n\n2時間程度の短いバージョンもありますが、こちらは3年前なので若干内容は古いです。\n\n実は最初に見つけたのはこちらの動画で、両方見ておいても復習にもなってよかったと思います。\n\n---\n\n### 2. 模擬問題集\n\n**問題集その①** \n\nUdemy講座\n\n【SAA-C03版】AWS 認定ソリューションアーキテクト アソシエイト模擬試験問題集（6回分390問）\n\nhttps://www.udemy.com/course/aws-knan/?srsltid=AfmBOoog7VooQtb3a4sIFj2XYfQTq61Z2QJJK1B3gp-2Xy1Ru-ZE-1LK&couponCode=KEEPLEARNING\n\n試験対策の主力となった問題集です。\n\n難易度が高め（本番試験と同じかやや難しいぐらい）なので、いきなりこれをやり始めてしまうと挫折してしまうかもしれません・・・\n\n本番と同じ65問のコースが1～6まであり、これを3周しました。\n\n最初は平均して正解率5割程度でしたが、3週目には合格水準と同じ7～8割までとれるようになりました。\n\n\n**問題集その②**\n\nCloudTech\n\nhttps://kws-cloud-tech.com/quizzes/saa%e8%b3%87%e6%a0%bc%e6%bc%94%e7%bf%92%e5%95%8f%e9%a1%8c%ef%bc%88%e7%84%a1%e6%96%9930%e5%95%8f%ef%bc%89\n\n登録すると、無料で30問演習問題が実施できます。\n\nまた、メールで80問分のPDF資料のリンクが送られてきます（内30問は無料分と同じ内容）\n\n難易度は基礎～試験と同じレベルぐらいです。\n\nこちらも計2周実施しました。\n\n**問題集その3**\n\nexam-net\n\nhttps://aws-exam.net/saa/\n\n無料で100問演習問題を実施できます。\n\n難易度は基礎～試験と同じレベルぐらいです。\n\nこちらも計2周しています。\n\n---\n\n### 3. ハンズオントレーニング\n\n**ハンズオントレーニングその①**\n\nUdemy講座\n\nAWS：ゼロから実践するAmazon Web Services。手を動かしながらインフラの基礎を習得\n\n山浦 清透さん\n\nhttps://www.udemy.com/course/aws-and-infra/?srsltid=AfmBOoqApVoV4pTX3oJvX7BGcQCJKUWyRmorxrOLug_1Z3i8FirXzJ_B&couponCode=KEEPLEARNING\n\n一番最初にAWSを学習した講座です。\n\nこのときはまだSAAを取るつもりはありませんでしたが、単純にAWSについての学習を実施したかったので講座を実践しました。\n\n冒頭でも書きましたが初心者向けの講座で、AWSを触る上では最低限必須の知識が身に付くと思います。\n\n頭の中にVPCやサーバーといった構成の全体がイメージできるようになるので、SAA試験を受ける上でも非常におすすめできます。\n\n（講座が作成されたのが数年前で、当時とAWSの仕様が変わっており、動画通りに進めるには苦労する点がいくつかあるのは注意点となります。ただ、筆者も調べながらなんとか最後までやり通すことはできました。）\n\n**ハンズオントレーニングその②**\n\n自身のブログサイトでAPIGateway + Lambda + DynamoDBを使った問い合わせフォームを作成しました。\n\nあまり参考にはならないかもしれませんが、下記の記事に当時詰まった点を記載しています。\n\nhttps://zenn.dev/masato24524/articles/49aef95c1253c2\n\n**ハンズオントレーニングその③**\n\nKinesisやCloudFormation、Athenaなどを使ったハンズオントレーニングを実施しました。\n\nこちらも下記の記事に記載していますので、よろしければ参考にしてみてください。\n\nhttps://zenn.dev/masato24524/articles/65bfd4816baffb\n\n---\n\n### さいごに\n\nはじめてのIT関係の資格試験だったので、合格できてよかったです。\n\n受験料も22000円（2025/5/21時点）と高いので、結構念入りに勉強して試験にのぞみました(^^;)\n\n少しでもこれから試験を受ける方の参考になれば幸いです。\n"
  },
  {
    "source": "github",
    "id": "eb15d09d0b289a",
    "title": "座標と二次元配列（行列）の基本操作",
    "emoji": "🌎",
    "type": "tech",
    "topics": [
      "JavaScript"
    ],
    "published": true,
    "date": "2025-04-26",
    "content": "最近paizaラーニングを始めました。\nhttps://paiza.jp/works\n\n- アルゴリズムの構築の仕方\n- メソッドの使い方\n\nなどが身に付くのでおすすめです。（無料でもある程度使えるようです）\n\n自身は今のところプログラミングスキルチェックの問題ばかりやっています。\n\n※問題の解答コード例が無かったりしますが、chatGPTに問題文をまるごとコピーして投げてやれば解答例のコードを教えてくれます。\n\n上記の問題の中で、座標と二次元配列（行列）の操作が必要になったので、学んだことを記載しておきます。\n\n---\n\n<目次>\n\n1. 座標系の移動\n2. 二次元配列のfor文\n\n---\n\n### 1. 座標系の移動\n\n問題文によっては文字列で移動すべき方向を指定されたりします。\n\n例えば、F（前）、B（後）、L（左）、R（右）のように定義されており、\n\n文字列で\"B R F\"と与えられた方向に座標を移動しないといけない場合\n\n下記のように文字列と配列の組み合わせを定義して、それを足し合わせることで現在の座標を動かします。\n\nF: [-1, 0],\nB: [1, 0],\nL: [0, -1],\nR: [0, 1]\n\n~~~javascript\n// 初期座標\nlet y = 0\nlet x = 0\nconst grid = [  \n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\n// 方向に合わせた配列を作成\nconst directions = {\nF: [-1, 0],\nB: [1, 0],\nL: [0, -1],\nR: [0, 1],\n};\n\n// 問題文の指示を入力\nconst s = \"BRF\"\n\nfor (let i = 0; i < s.length; i++) {\n    const dir = s[i];\n    const [dy, dx] = directions[dir];\n    y += dy;\n    x += dx;\n    console.log(grid[y][x]);\n}\n\n// 結果\n4 // grid[1][0]の数字\n5 // grid[1][1]の数字\n2 // grid[0][1]の数字\n\n~~~\n\nfor文で文字列を順に取り出して、grid内の数字を順に取り出しています。\n\nちょっと説明が不十分かもしれませんが、、、雰囲気は分かってもらえると思います。\n\n---\n\n### 2. 二次元配列のfor文\n\n二次元配列にfor文を二回重ねてやると、全ての数字に順にアクセスできます。\n\nさらに、二次元配列のfor文を回す際にjとiを入れ替えると列方向の数字を取り出すことができます。（転置行列の作成）\n\n~~~javascript\nconst grid = [  \n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nconst newGrid = [];\n\nfor (let i = 0; i < 3; i++) {\n    const temp = [];\n    for (let j = 0; j < 3; j++) {\n        temp.push(grid[j][i]); // ここでj,iの順番を入れ替える\n    }\n    newGrid.push(temp); // tempを1つの配列としてnewGridに追加\n}\n\nconsole.log(newGrid);\n\n// 結果\n[  \n    [1, 4, 7],\n    [2, 5, 8],\n    [3, 6, 9]\n];\n\n~~~\n\nググるとこの操作も1行でできたりするみたいですが^^;\n\n理解して身に付けるには上記のようなコードを作成してみるのは効果的ですね。\n\n---\n\n## 所感\n\n行列の操作は今まであまり触れてなかったんですが、\n\npaizaラーニングだとわんさか求められるので、嫌でも身に付いていきそうです。。。\n\nトレーニングを続けて、さらに自由に扱えるようになりたいと思います。"
  },
  {
    "source": "github",
    "id": "eb87246a0bada1",
    "title": "Next.jsの環境変数のセキュリティ",
    "emoji": "🔐",
    "type": "tech",
    "topics": [
      "nextjs",
      "blog",
      "環境変数"
    ],
    "published": true,
    "date": "2025-02-17",
    "content": "\n### 執筆者について\n実務未経験＆プログラム歴1年未満です。\n\n### 記事本文\n自信のブログ記事をNext.js（ver.14）＋microCMSで構築していますが、途中のエラー対応の理解が浅く、場当たり的な対応をしていたこともあり、重要なセキュリティ問題があったことが分かりました。\nhttps://www.masato-tech-blog.com/\n\n\n環境変数にNEXT_PUBRICを付けていたため、開発者ツールからAPI_KEYを確認できる状態でした。\n\n```typescript\nNEXT_PUBLIC_API_KEY=【API KEY】\n```\n【今回の教訓】\nNEXT_PUBRICのプレフィックスを安易に使わない\n\n#### ■変更前\n\nmicroCMSのクライアントライブラリを使って記事データを取得していました。\n```typescript\nconst client = createClient({\n  serviceDomain: 'your-service-domain',\n  apiKey: process.env.NEXT_PUBLIC_API_KEY,\n});\n```\nこの実装では、NEXT_PUBLICプレフィックスによって環境変数がクライアントサイドのJavaScriptに含まれてしまいます。これは、Next.jsの仕様でNEXT_PUBLICが付いた環境変数はビルド時にバンドルに含まれるためです。結果として、ブラウザの開発者ツールからAPI_KEYが確認できてしまう状態となっていました。\n\n\n#### ■変更後\n\nこの問題を解決するため、ファイルルーティングの構造を変更しました。具体的には、以下のようにAPI Routeを実装し、API経由でブログ記事を取得することで、クライアントサイドからAPI Keyが見えないようにしました\nNext.jsではapiフォルダを配置することで、APIエンドポイントとして使用できます：\n```typescript\n// app/api/route.ts\nimport { createClient } from 'microcms-js-sdk';\nimport { NextResponse } from 'next/server';\n\nconst client = createClient({\n  serviceDomain: 'your-service-domain',\n  apiKey: process.env.API_KEY, // NEXT_PUBLICプレフィックスを削除\n});\n\nexport async function GET() {\n  const data = await client.get({\n    endpoint: 'blogs',\n  });\n  \n  return NextResponse.json(data);\n}\n```\n\n### まとめ\nAPI Routeを使用することで、クライアントサイドに露出させることなく、安全にmicroCMSの記事を取得できるようになりました。\nたぶん初心者にありがちなミスと思いますが、付け焼刃でセキュリティキーを扱うのは危険が伴うので、十分な注意が必要ですね。\n\n※この他にもクライアントサイドでcreateClient()を使用しているファイルをインポートする場合でも露出してしまうようです。今回であればFooter.tsxを'use client'に設定しており、そこからcreateClientを使っているファイルをインポートしてしまっていました。\n\n大変だったのは今回のAPIルートを導入したことによってVercelにデプロイする際に別の問題が発生し、そちらに時間がかかり苦労しました。それについては別途記事にしたいと思います。\n\n\n\n\n"
  },
  {
    "source": "github",
    "id": "f6cc43d8f835a2",
    "title": "splitメソッド、reduceメソッドの学習",
    "emoji": "📘",
    "type": "tech",
    "topics": [
      "JavaScript"
    ],
    "published": true,
    "date": "2025-04-19",
    "content": "\nJavaScriptの基礎的な内容ですが、自身の学習のために記載しておこうと思います。\n\n---\n\n#### splitメソッド\n\n問題：\n\"5 2 4\"のような数字（文字列）の入力が与えられているとする。\nこれらの入力を配列に変換するには？\n\n（下記ではさらに中身を数字に変換し、配列を一つずつ変数に代入）\n\n~~~javascript\nconst numbers = \"5 2 4\"\nconst [A, B, C] = numbers.split(\" \").map(Number)\nconsole.log(A)\nconsole.log(B)\nconsole.log(C)\n\n出力結果：\n5\n2\n4\n~~~\n\n<br/>\n＜メモ＞\n\n- 「const [A, B, C] =」　の部分は分割代入と呼ばれるもので、\n作成された配列を一つずつ変数に代入することが可能\n\n- split(\"\")（ダブルクォーテーションの間にスペースがない）だと、間のスペースも文字列として分割されてしまう。<br/>\nconsole.log(numbers.split(\"\"))= ['5', ' ', '2', ' ', '4']\nとなる。\n\n- map(Number)で文字列の配列を数字に変換している（NumberはJavaScriptに最初からある組み込み関数）\n\n---\n\n#### reduceメソッド\n\n問題：\nconst users = [\n  { id: 1, name: \"田中\", department: \"営業\", sales: 1200000 },\n  { id: 2, name: \"鈴木\", department: \"技術\", sales: 0 },\n  { id: 3, name: \"佐藤\", department: \"営業\", sales: 980000 }\n];\n上記のデータのうち、部署ごとの集計を行うには？\n\n~~~javascript\nconst sum = users.reduce((acc, user) => {\n    if(!acc[user.department]) {\n        acc[user.department] = 0;\n    }\n    acc[user.department] += user.sales;\n    return acc;\n}, {});\n\nconsole.log(sum);\n\n出力結果：\n{営業: 2280000, 技術: 0}\n~~~\n\n＜メモ＞\n- (acc, user) => {\n    if(!acc[user.department]) {\n        acc[user.department] = 0;\n    }\n    acc[user.department] += user.sales;\n    return acc;\n}\nこの部分がコールバック関数となっている。\n\nコールバック関数部分の第一引数(acc)、第二引数(user)の名前はなんでもよい。\n\naccは集計結果を保持するオブジェクト。\n\nuserにはusersの各要素（＝オブジェクト）が順番に渡される。\n\n第一引数[第二引数（オブジェクト）.key]でどのkeyに基づいて合計するか指定でき、keyそれぞれで合計される。\n\n-    if(!acc[user.department]) {\n        acc[user.department] = 0;\n    }\n    この部分ではaccオブジェクトの中に対応するkey（ここではuser.department）が存在しない場合に0で初期化している。\n    初期化しない場合はundefinedとなり、数値を足そうとするとエラーが発生する。\n<br/>\n- }, {});\n\n　末尾のこの{}の部分には初期値を設定できる。\n\n　例えば{技術:1000000}としておくと、{営業: 2280000, 技術: 1000000}と出力される。\n\n\n---\n\n### 所感\n　調べものをしているうちにたまたま出てきたメソッドについて、基本的な使い方をまとめてみました。\n\n今回の内容ぐらいは、何も調べずに操作できるようになりたいですね。\n"
  }
]